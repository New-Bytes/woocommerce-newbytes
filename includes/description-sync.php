<?php

/**
 * Sincronización de descripciones de productos NewBytes
 * Descarga todas las descripciones de /autoGeneratedDescriptions en un solo GET
 * Filtra por productos existentes en nb-products y procesa localmente por lotes
 */

// Evitar acceso directo
if (!defined('ABSPATH')) {
    exit;
}

/**
 * Clase para gestionar la sincronización de descripciones
 */
class NB_Description_Manager
{
    private static $base_dir;      // nb-descriptions/
    private static $logs_dir;      // nb-descriptions/logs/ - archivos crudos de la API
    private static $update_dir;    // nb-descriptions/update/ - archivos filtrados para sincronizar
    
    /**
     * Inicializar los directorios de descripciones
     */
    private static function init_descriptions_dir()
    {
        if (empty(self::$base_dir)) {
            self::$base_dir = plugin_dir_path(__FILE__) . '../nb-descriptions/';
            self::$logs_dir = self::$base_dir . 'logs/';
            self::$update_dir = self::$base_dir . 'update/';
        }
        
        // Asegurar que los directorios existen
        $dirs = array(self::$base_dir, self::$logs_dir, self::$update_dir);
        foreach ($dirs as $dir) {
            if (!file_exists($dir)) {
                if (!mkdir($dir, 0755, true)) {
                    wp_mkdir_p($dir);
                }
            }
            
            // Asegurar permisos de escritura
            if (is_dir($dir) && !is_writable($dir)) {
                @chmod($dir, 0755);
                if (!is_writable($dir)) {
                    @chmod($dir, 0775);
                }
            }
            
            // Crear archivo index.php de protección
            $index_file = $dir . 'index.php';
            if (!file_exists($index_file) && is_writable($dir)) {
                file_put_contents($index_file, "<?php\n// Silence is golden.\n");
            }
        }
    }
    
    /**
     * Descarga todas las descripciones desde /autoGeneratedDescriptions y las guarda en JSON
     * 
     * @return array Resultado con 'success', 'filepath', 'total' o 'error'
     */
    public static function download_all_descriptions()
    {
        self::init_descriptions_dir();
        
        try {
            // Obtener token de autenticación
            $token = nb_get_token();
            if (!$token) {
                return array(
                    'success' => false,
                    'error' => 'No fue posible obtener el token de autenticación.'
                );
            }
            
            // Llamar a la API para obtener todas las descripciones
            $url = API_URL_NB . '/autoGeneratedDescriptions';
            $args = array(
                'headers' => array(
                    'Authorization' => 'Bearer ' . $token,
                    'Content-Type' => 'application/json'
                ),
                'timeout' => 120, // Timeout más largo porque puede ser mucha data
                'blocking' => true,
            );
            
            nb_log('Descargando todas las descripciones desde /autoGeneratedDescriptions', 'info');
            
            $response = wp_remote_get($url, $args);
            
            if (is_wp_error($response)) {
                return array(
                    'success' => false,
                    'error' => 'Error en la solicitud a la API: ' . $response->get_error_message()
                );
            }
            
            $status_code = wp_remote_retrieve_response_code($response);
            if ($status_code !== 200) {
                return array(
                    'success' => false,
                    'error' => 'Error HTTP ' . $status_code . ' al obtener descripciones'
                );
            }
            
            $body = wp_remote_retrieve_body($response);
            $json_data = json_decode($body, true);
            
            if (json_last_error() !== JSON_ERROR_NONE) {
                return array(
                    'success' => false,
                    'error' => 'Error al decodificar JSON de la API: ' . json_last_error_msg()
                );
            }
            
            // Crear nombre del archivo con formato: nb-description-YYYY-MM-DD_HH-mm.json
            // Se guarda en logs/ para mantener ordenados los archivos crudos de la API
            $timestamp = current_time('Y-m-d_H-i');
            $filename = 'nb-description-' . $timestamp . '.json';
            $filepath = self::$logs_dir . $filename;
            
            // Guardar JSON crudo
            $json_content = json_encode($json_data, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
            
            if (file_put_contents($filepath, $json_content) === false) {
                return array(
                    'success' => false,
                    'error' => 'Error al guardar el archivo JSON de descripciones.'
                );
            }
            
            // Limpiar archivos antiguos (mantener máximo 5)
            self::cleanup_old_descriptions(5);
            
            nb_log('Archivo JSON de descripciones generado: ' . $filename, 'info', array(
                'total_descriptions' => count($json_data)
            ));
            
            return array(
                'success' => true,
                'filepath' => $filepath,
                'filename' => $filename,
                'total' => count($json_data)
            );
            
        } catch (Exception $e) {
            nb_log('Error descargando descripciones: ' . $e->getMessage(), 'error');
            return array(
                'success' => false,
                'error' => 'Excepción: ' . $e->getMessage()
            );
        }
    }
    
    /**
     * Crea archivo filtrado con solo las descripciones de productos existentes en nb-products
     * 
     * @return array Resultado con 'success', 'filepath', 'total', 'filtered' o 'error'
     */
    public static function create_filtered_update_file()
    {
        global $wpdb;
        
        self::init_descriptions_dir();
        
        // 1. Leer el JSON de productos más reciente (nb-products-{fecha}.json)
        $products_result = NB_Product_Manager::read_latest_products_json();
        
        if (!$products_result['success']) {
            return array(
                'success' => false,
                'error' => $products_result['error']
            );
        }
        
        $products_data = $products_result['data'];
        
        if (!is_array($products_data) || empty($products_data)) {
            return array(
                'success' => false,
                'error' => 'El archivo de productos está vacío. Ejecute primero una sincronización.'
            );
        }
        
        // 2. Obtener los SKUs que realmente existen en WooCommerce
        $prefix = get_option('nb_prefix', 'NB_');
        $existing_skus = $wpdb->get_col($wpdb->prepare(
            "SELECT meta_value FROM {$wpdb->postmeta} pm
             INNER JOIN {$wpdb->posts} p ON pm.post_id = p.ID
             WHERE pm.meta_key = '_sku' 
             AND pm.meta_value LIKE %s
             AND p.post_type = 'product'
             AND p.post_status = 'publish'",
            $prefix . '%'
        ));
        
        // Crear set de SKUs sin prefijo para búsqueda rápida
        $existing_skus_set = array();
        foreach ($existing_skus as $sku) {
            // Remover el prefijo para comparar con el SKU de la API
            $sku_without_prefix = str_replace($prefix, '', $sku);
            $existing_skus_set[$sku_without_prefix] = true;
        }
        
        // 3. Crear mapeo de id -> producto, pero solo si el SKU existe en WooCommerce
        $products_map = array();
        foreach ($products_data as $product) {
            if (isset($product['id']) && isset($product['sku'])) {
                // Solo incluir si el SKU existe en WooCommerce
                if (isset($existing_skus_set[$product['sku']])) {
                    $products_map[$product['id']] = array(
                        'id' => $product['id'],
                        'sku' => $product['sku'],
                        'title' => isset($product['title']) ? $product['title'] : ''
                    );
                }
            }
        }
        
        // 4. Leer el JSON de descripciones más reciente (nb-description-{fecha}.json)
        $desc_result = self::read_latest_descriptions_json();
        
        if (!$desc_result['success']) {
            return $desc_result;
        }
        
        $all_descriptions = $desc_result['data'];
        
        // 5. Filtrar: solo descripciones cuyos 'codigo' existan en products_map (productos en WooCommerce)
        $filtered_descriptions = array();
        foreach ($all_descriptions as $desc_item) {
            $codigo = isset($desc_item['codigo']) ? $desc_item['codigo'] : null;
            
            if ($codigo && isset($products_map[$codigo])) {
                // Agregar info del producto al item filtrado
                $filtered_descriptions[] = array(
                    'codigo' => $codigo,
                    'description' => isset($desc_item['description']) ? $desc_item['description'] : '',
                    'sku' => $products_map[$codigo]['sku'],
                    'title' => $products_map[$codigo]['title']
                );
            }
        }
        
        // 5. Guardar archivo filtrado en update/nb-description-update-{fecha}.json
        $timestamp = current_time('Y-m-d_H-i');
        $filename = 'nb-description-update-' . $timestamp . '.json';
        $filepath = self::$update_dir . $filename;
        
        $json_content = json_encode($filtered_descriptions, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
        
        if (file_put_contents($filepath, $json_content) === false) {
            return array(
                'success' => false,
                'error' => 'Error al guardar el archivo JSON filtrado.'
            );
        }
        
        // 6. Limpiar archivos antiguos de update (mantener máximo 3)
        self::cleanup_old_update_files(3);
        
        nb_log('Archivo JSON de descripciones filtrado generado: ' . $filename, 'info', array(
            'total_descriptions' => count($all_descriptions),
            'filtered_descriptions' => count($filtered_descriptions),
            'total_products' => count($products_map)
        ));
        
        return array(
            'success' => true,
            'filepath' => $filepath,
            'filename' => $filename,
            'total_api' => count($all_descriptions),
            'total_products' => count($products_map),
            'filtered' => count($filtered_descriptions)
        );
    }
    
    /**
     * Obtiene el archivo JSON de update más reciente
     * 
     * @return array|false Datos del archivo o false si no existe
     */
    public static function get_latest_update_json()
    {
        self::init_descriptions_dir();
        
        $files = glob(self::$update_dir . 'nb-description-update-*.json');
        
        if (empty($files)) {
            return false;
        }
        
        // Ordenar por fecha de modificación descendente
        usort($files, function($a, $b) {
            return filemtime($b) - filemtime($a);
        });
        
        $latest_file = $files[0];
        
        return array(
            'filepath' => $latest_file,
            'filename' => basename($latest_file),
            'modified' => filemtime($latest_file),
            'size' => filesize($latest_file)
        );
    }
    
    /**
     * Lee el contenido del archivo JSON de update más reciente
     * 
     * @return array Resultado con 'success', 'data' o 'error'
     */
    public static function read_latest_update_json()
    {
        $latest = self::get_latest_update_json();
        
        if (!$latest) {
            return array(
                'success' => false,
                'error' => 'No se encontró ningún archivo de actualización. Ejecute primero la preparación.'
            );
        }
        
        $content = file_get_contents($latest['filepath']);
        
        if ($content === false) {
            return array(
                'success' => false,
                'error' => 'Error al leer el archivo: ' . $latest['filename']
            );
        }
        
        $data = json_decode($content, true);
        
        if (json_last_error() !== JSON_ERROR_NONE) {
            return array(
                'success' => false,
                'error' => 'Error al decodificar JSON: ' . json_last_error_msg()
            );
        }
        
        return array(
            'success' => true,
            'data' => $data,
            'file_info' => $latest
        );
    }
    
    /**
     * Limpia archivos JSON antiguos de update
     * 
     * @param int $max_files Número máximo de archivos a mantener
     * @return int Número de archivos eliminados
     */
    public static function cleanup_old_update_files($max_files = 3)
    {
        self::init_descriptions_dir();
        
        $deleted_count = 0;
        $files = glob(self::$update_dir . 'nb-description-update-*.json');
        
        if (count($files) <= $max_files) {
            return $deleted_count;
        }
        
        // Ordenar por fecha de modificación descendente
        usort($files, function($a, $b) {
            return filemtime($b) - filemtime($a);
        });
        
        // Eliminar los archivos excedentes
        $files_to_delete = array_slice($files, $max_files);
        
        foreach ($files_to_delete as $file) {
            if (unlink($file)) {
                $deleted_count++;
            }
        }
        
        return $deleted_count;
    }

    /**
     * Obtiene el archivo JSON de descripciones más reciente
     * 
     * @return array|false Datos del archivo o false si no existe
     */
    public static function get_latest_descriptions_json()
    {
        self::init_descriptions_dir();
        
        // Buscar en logs/ los archivos crudos de la API
        $files = glob(self::$logs_dir . 'nb-description-*.json');
        
        if (empty($files)) {
            return false;
        }
        
        // Ordenar por fecha de modificación descendente
        usort($files, function($a, $b) {
            return filemtime($b) - filemtime($a);
        });
        
        $latest_file = $files[0];
        
        return array(
            'filepath' => $latest_file,
            'filename' => basename($latest_file),
            'modified' => filemtime($latest_file),
            'size' => filesize($latest_file)
        );
    }
    
    /**
     * Lee el contenido del archivo JSON de descripciones más reciente
     * 
     * @return array Resultado con 'success', 'data' o 'error'
     */
    public static function read_latest_descriptions_json()
    {
        $latest = self::get_latest_descriptions_json();
        
        if (!$latest) {
            return array(
                'success' => false,
                'error' => 'No se encontró ningún archivo JSON de descripciones. Ejecute primero la descarga.'
            );
        }
        
        $content = file_get_contents($latest['filepath']);
        
        if ($content === false) {
            return array(
                'success' => false,
                'error' => 'Error al leer el archivo: ' . $latest['filename']
            );
        }
        
        $data = json_decode($content, true);
        
        if (json_last_error() !== JSON_ERROR_NONE) {
            return array(
                'success' => false,
                'error' => 'Error al decodificar JSON: ' . json_last_error_msg()
            );
        }
        
        return array(
            'success' => true,
            'data' => $data,
            'file_info' => $latest
        );
    }
    
    /**
     * Limpia archivos JSON antiguos de descripciones
     * 
     * @param int $max_files Número máximo de archivos a mantener
     * @return int Número de archivos eliminados
     */
    public static function cleanup_old_descriptions($max_files = 5)
    {
        self::init_descriptions_dir();
        
        $deleted_count = 0;
        // Buscar en logs/ los archivos crudos de la API
        $files = glob(self::$logs_dir . 'nb-description-*.json');
        
        if (count($files) <= $max_files) {
            return $deleted_count;
        }
        
        // Ordenar por fecha de modificación descendente
        usort($files, function($a, $b) {
            return filemtime($b) - filemtime($a);
        });
        
        // Eliminar los archivos excedentes
        $files_to_delete = array_slice($files, $max_files);
        
        foreach ($files_to_delete as $file) {
            if (unlink($file)) {
                $deleted_count++;
                nb_log('Archivo JSON de descripciones eliminado: ' . basename($file), 'debug');
            }
        }
        
        return $deleted_count;
    }
}

/**
 * AJAX: Preparar actualización de descripciones
 * 1. Descarga productos desde la API (nb-products-{fecha}.json)
 * 2. Descarga todas las descripciones desde la API (nb-description-{fecha}.json)
 * 3. Filtra descripciones por productos existentes
 * 4. Crea archivo nb-description-update-{fecha}.json
 */
function nb_ajax_prepare_descriptions()
{
    // Verificar nonce
    if (!isset($_POST['nonce']) || !wp_verify_nonce($_POST['nonce'], 'nb_sync_nonce')) {
        wp_send_json_error(array('message' => 'Nonce inválido'));
    }

    // Verificar permisos
    if (!current_user_can('manage_options')) {
        wp_send_json_error(array('message' => 'Sin permisos'));
    }

    try {
        // Limpiar transients para asegurar datos frescos
        delete_transient('nb_description_stats');
        
        // 1. Descargar productos desde la API (igual que sincronización normal)
        $products_result = NB_Product_Manager::generate_products_json();
        
        if (!$products_result['success']) {
            wp_send_json_error(array('message' => 'Error descargando productos: ' . $products_result['error']));
        }
        
        nb_log('Productos descargados para actualización de descripciones', 'info', array(
            'total_products' => $products_result['total_products'],
            'filename' => $products_result['filename']
        ));
        
        // 2. Descargar todas las descripciones desde la API
        $download_result = NB_Description_Manager::download_all_descriptions();

        if (!$download_result['success']) {
            wp_send_json_error(array('message' => $download_result['error']));
        }

        // 3. Crear archivo filtrado cruzando productos con descripciones
        $filter_result = NB_Description_Manager::create_filtered_update_file();

        if (!$filter_result['success']) {
            wp_send_json_error(array('message' => $filter_result['error']));
        }

        // Calcular tiempo estimado (0.05 segundos por descripción filtrada)
        $estimated_seconds = $filter_result['filtered'] * 0.05;
        $estimated_time = nb_format_estimated_time($estimated_seconds);

        wp_send_json_success(array(
            'total_api' => $filter_result['total_api'],
            'total_products' => $filter_result['total_products'],
            'total_descriptions' => $filter_result['filtered'],
            'estimated_seconds' => $estimated_seconds,
            'estimated_time' => $estimated_time,
            'json_file' => $filter_result['filename']
        ));

    } catch (Exception $e) {
        wp_send_json_error(array('message' => 'Error: ' . $e->getMessage()));
    }
}

/**
 * AJAX: Procesar lote de descripciones desde el archivo filtrado
 */
function nb_ajax_process_descriptions_batch()
{
    // Verificar nonce
    if (!isset($_POST['nonce']) || !wp_verify_nonce($_POST['nonce'], 'nb_sync_nonce')) {
        wp_send_json_error(array('message' => 'Nonce inválido'));
    }

    // Verificar permisos
    if (!current_user_can('manage_options')) {
        wp_send_json_error(array('message' => 'Sin permisos'));
    }

    $offset = isset($_POST['offset']) ? intval($_POST['offset']) : 0;
    $batch_size = isset($_POST['batch_size']) ? intval($_POST['batch_size']) : 50;

    try {
        // Aumentar límites para el procesamiento
        ini_set('max_execution_time', '300');
        ini_set('memory_limit', '512M');

        // Leer el JSON filtrado de update (nb-description-update-{fecha}.json)
        $read_result = NB_Description_Manager::read_latest_update_json();

        if (!$read_result['success']) {
            wp_send_json_error(array('message' => $read_result['error']));
        }

        $all_descriptions = $read_result['data'];
        $total_descriptions = count($all_descriptions);

        // Obtener el lote actual
        $batch = array_slice($all_descriptions, $offset, $batch_size);
        
        if (empty($batch)) {
            // No hay más descripciones, finalizar
            wp_send_json_success(array(
                'completed' => true,
                'processed' => $offset,
                'total' => $total_descriptions,
                'batch_updated' => 0
            ));
        }

        // Procesar el lote de descripciones
        $result = nb_process_descriptions_batch($batch);

        $new_offset = $offset + count($batch);
        $is_completed = $new_offset >= $total_descriptions;

        // Si es el último lote, actualizar fecha
        if ($is_completed) {
            update_option('nb_last_description_update', current_time('mysql'));
            
            // Obtener estadísticas totales de la sesión
            $stats = get_transient('nb_description_stats');
            if (!$stats) {
                $stats = array('updated' => 0, 'not_found' => 0);
            }
            
            // Sumar estadísticas del lote actual
            $stats['updated'] += $result['updated'];
            $stats['not_found'] += $result['not_found'];
            
            // Limpiar transient
            delete_transient('nb_description_stats');
            
            nb_log('Actualización de descripciones completada', 'info', $stats);
        } else {
            // Guardar estadísticas parciales
            $stats = get_transient('nb_description_stats');
            if (!$stats) {
                $stats = array('updated' => 0, 'not_found' => 0);
            }
            $stats['updated'] += $result['updated'];
            $stats['not_found'] += $result['not_found'];
            set_transient('nb_description_stats', $stats, 3600);
        }

        wp_send_json_success(array(
            'completed' => $is_completed,
            'processed' => $new_offset,
            'total' => $total_descriptions,
            'batch_updated' => $result['updated'],
            'batch_not_found' => $result['not_found'],
            'stats' => $is_completed ? $stats : null
        ));

    } catch (Exception $e) {
        wp_send_json_error(array('message' => 'Error: ' . $e->getMessage()));
    }
}

/**
 * Procesar un lote de descripciones desde el archivo filtrado
 * El archivo filtrado ya contiene: codigo, description, sku, title
 * 
 * @param array $batch Lote de descripciones [{codigo, description, sku, title}, ...]
 * @return array Resultado con 'updated' y 'not_found'
 */
function nb_process_descriptions_batch($batch)
{
    $prefix = get_option('nb_prefix', 'NB_');
    $additional_description = get_option('nb_description', '');
    
    $updated_count = 0;
    $not_found_count = 0;

    // Desactivar hooks pesados
    wp_defer_term_counting(true);
    wp_defer_comment_counting(true);

    foreach ($batch as $item) {
        // El archivo filtrado ya tiene el SKU del producto
        $sku = isset($item['sku']) ? $item['sku'] : '';
        $description = isset($item['description']) ? $item['description'] : '';
        
        if (empty($sku)) {
            $not_found_count++;
            continue;
        }
        
        // Construir SKU completo con prefijo
        $full_sku = $prefix . $sku;
        
        // Buscar producto por SKU en WooCommerce
        $product_id = wc_get_product_id_by_sku($full_sku);
        
        if ($product_id) {
            try {
                $product = wc_get_product($product_id);
                
                if ($product) {
                    // Combinar descripción adicional con la de la API
                    $full_description = trim($additional_description . ' ' . $description);
                    $product->set_description($full_description);
                    $product->save();
                    $updated_count++;
                } else {
                    $not_found_count++;
                }
            } catch (Exception $e) {
                error_log('[NewBytes] Error actualizando descripción SKU ' . $full_sku . ': ' . $e->getMessage());
                $not_found_count++;
            }
        } else {
            $not_found_count++;
        }
    }

    // Restaurar hooks
    wp_defer_term_counting(false);
    wp_defer_comment_counting(false);

    return array(
        'updated' => $updated_count,
        'not_found' => $not_found_count
    );
}

// Registrar acciones AJAX
add_action('wp_ajax_nb_prepare_descriptions', 'nb_ajax_prepare_descriptions');
add_action('wp_ajax_nb_process_descriptions_batch', 'nb_ajax_process_descriptions_batch');
